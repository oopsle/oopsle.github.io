<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:xhtml="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
	<link href="https://fonts.googleapis.com/css?family=Architects+Daughter" rel="stylesheet" type="text/css"/>
	<link rel="stylesheet" type="text/css" href="../css/main.css" media="screen" />
	<link rel="stylesheet" type="text/css" href="../css/print.css" media="print" />
    <title>Open and Original Problems in Software Language Engineering</title>
</head>

<body>
	<div class="header">
		<img src="../images/oopsle-2015.png" alt="Open and Original Problems in Software Language Engineering"/>
		<div class="inner">
			<h1><a href="..">OOPSLE</a></h1>
			<h2>Third International Workshop on Open and Original Problems in
				Software Language Engineering</h2>
			<h3>6 March 2015, Montréal, Canada</h3>
			<h3>Co-located with <a href="http://saner.soccerlab.polymtl.ca/">SANER’15</a> (formerly <a href="http://dblp.org/db/conf/csmr/index.html">CSMR</a> and <a href="http://dblp.org/db/conf/wcre/index.html">WCRE</a>)</h3>
		</div>
	</div>
	<div id="content-wrapper">
	<div class="maininner">
	<div id="main-content">
		<h1>Workshop programme and abstracts</h1>
		<p/>
		<h2>9:00 – 9:15 Opening and welcome of OOPSLE’15</h2>
		<p class="bi">
			<a href="http://www.ii.uib.no/~anya/">Anya Helene Bagge</a> (BLDL, Uni. Bergen),
			<a href="http://grammarware.net/">Vadim Zaytsev</a> (SE, Uni. Amsterdam)
		</p>
		<p>
			We will briefly reintroduce the workshop and summarise its goals and
			topics discussed at previous two editions (<a href="http://oopsle.github.io/2014/">OOPSLE’14</a>
			&amp; <a href="http://oopsle.github.io/2013/">OOPSLE’13</a>).
		</p>

		<h2 id="cordy">9:15 – 10:30 Keynote: Source Transformation on Boolean Grammars: Advantages and Challenges (<a href="STBG.pdf">slides</a>)</h2>
		<p class="bi">
			<a href="http://research.cs.queensu.ca/home/cordy/">James R. Cordy</a> (Queen’s)
		</p>
		<p>
			Boolean grammars offer an extension to context-free grammar notation
			that adds conjunction (<tt>and</tt>, <tt>&amp;</tt>) and anti-conjunction (<tt>and not</tt>, <tt>&amp;!</tt>) to
			traditional disjunctive alternative (<tt>or</tt>, <tt>|</tt>) production rules.  “And” simply means
			that a matched input string must conform to both of two grammatical forms,
			and “and not” means that it must conform to the first, but not the second.
			 In the language theory community, Alex Okhotin has shown that Boolean
			grammars can recognize a significantly larger set of languages than context-free,
			while retaining reasonably efficient (polynomial) parse complexity.
		</p><p>
			In this talk I will outline our experience in implementing a practical Boolean
			parser for TXL, a popular production source transformation system, both
			to support a larger set of input languages, and to allow for direct implementation
			of the notion of "agile parsing”, using Boolean productions to specify multiple
			simultaneous parse “views” of the same input in order to facilitate different
			transformation tasks.  Along the way we will discover that source transformation
			in the presence of Boolean grammars is not nearly so straightforward
			an extension of transformation rules as it is for grammar rules.
		</p>

		<h2 id="hill">11:00 – 11:45 Engineering Iron Man’s JARVIS (<a href="JARVIS.pdf">slides</a>)</h2>
		<p class="bi">
			<a href="http://www.drew.edu/mcs/faculty#peter">Emily Hill</a> (Drew)
		</p>
		<p>
			The purpose of programming languages is to facilitate communication between the programmer and the machine, i.e., to allow a human to tell a computer what to do.  With each new language paradigm, we inch ever closer to natural expressiveness, making our programs readable as well as runnable. But the question remains: how close should programming language design strive to mimic the naturalness of human expression? In the science fiction movie <em>Iron Man</em>, Tony Stark speaks to his computer, JARVIS (Just A Rather Very Intelligent System), like he would to a friend. They banter sarcastically while JARVIS executes Tony’s high level number crunching tasks. Does this example from science fiction represent the holy grail of software language engineering, namely, that a human need only specify a high-level task to have a computer execute it?
		</p>

		<h2 id="diskin">11:45 – 12:30 Sociology of Model Management: Why Model Mappings are to Be the First-class Citizens in MDE</h2>
		<p class="bi">
			<a href="http://gsd.uwaterloo.ca/zdiskin">Zinovy Diskin</a> (McMaster/Waterloo)
		</p>
		<p>
			The importance of intermodel mappings for model management (MMt) is generally recognized, but they are normally considered  as auxiliary objects useful  for traceability and matching .  We will consider several examples showing that mappings  play several fundamental rather than technological roles: they are crucial for specifying a proper semantics of MMt operations,  and for correct chaining of these operations into a workflow as well.  Moreover,  the most important model transforrmations — source-to-target model translations — can be compactly  encoded by mappings as well,  and then be algebraically manipulated as holistic  objects.  In a sense,  MMt is all about inter-model mappings and their interaction, and thus is about sociology of models rather than individual models as such. 
		</p><p>
			Mappings are two-sided objects. On the one hand, they are directed and can be sequentially composed. On the other hand, mappings are sets of links and hence carry Boolean operations of intersection, union, and difference.   Due to this “schizophrenic” nature of mappings, their management needs a special conceptual and terminological framework, a convenient notation, and  special reasoning techniques. All this is provided by mathematical  Category Theory (CT), whose subject is sometimes called a sociology of mathematical structures based on their mappings.  Not surprisingly, sociological  specificational and reasoning patterns  of CT make a good match with the sociological problems  of MMt.
		</p>

		<h2 id="serebrenik">14:00 – 14:45 Software Languages: Designing for Humans? (<a href="SLDH.pdf">slides</a>)</h2>
		<p class="bi">
			<a href="http://www.win.tue.nl/~aserebre/">Alexander Serebrenik</a> (TU/e)
		</p>
		<p>
			The idea would be to start with a rather obvious observation that the users of software languages, as any users of any systems, are different. Indeed, differences between the users might be beneficial [e.g., our CHI 2015]. Moreover, those users have special needs that must be taken account of [Norman, 1983]—we have seen that the current design, for instance, of StackOverflow is unsuccessful in retaining women [IWC 2014] and <a href="http://michael.richter.name/blogs/why-i-no-longer-contribute-to-stackoverflow">complaints</a> are being heard of the poor reward system and poor pedagogy. Then I can talk a little bit about the existing design strategies aiming at including women and problems with those strategies. Finally, I would like to ask the audience whether they recognise those challenges as being relevant to design of software languages.
		</p>

		<h2 id="hills">14:45 – 15:30 Domain-Specific Languages for Program Analysis (<a href="DSLPA.pdf">PDF</a>, <a href="DSLPA-slides.pdf">slides</a>)</h2>
		<p class="bi">
			<a href="http://www.cs.ecu.edu/hillsma/">Mark Hills</a> (ECU)
		</p>
		<p>
			Program analysis is an important aspect of many software language engineering tools. As part of our work on creating program analysis tools and frameworks in Rascal, we are looking at creating domain-specific languages to support different program analysis tasks, reducing the effort to develop new analysis tools and providing effective notations and libraries. We have created a language for defining control flow for the purpose of building control flow graphs, and are looking at languages for other analysis tasks, such as generating function summaries for library functions based on program documentation.
		</p>

		<h2 id="ubayashi">16:00 – 16:45 Uncertainty-Aware Programming (<a href="UAP.pdf">PDF</a>)</h2>
		<p class="bi">
			<a href="http://posl.ait.kyushu-u.ac.jp/~ubayashi/">Naoyasu Ubayashi</a> (Kyushu)
		</p>
		<p>
			Uncertainty is one of the crucial research topics in software engineering, because all of the requirements or design concerns cannot be captured at the early development phase. This presentation introduces an idea of uncertainty-aware programming and discusses the problems to be tackled. 
		</p>

		<h2>16:45 – 17:15 Discussion</h2>
		<h2>19:00 Dinner</h2>
	</div>

	<div class="sidebar">
	  <p><a href="http://oopsle.github.io/2015/">OOPSLE’15</a></p>
	</div>
	</div>
	</div>
</body>
</html>
